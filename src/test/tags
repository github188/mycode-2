!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ARR_MAX	middle_number.c	6;"	d	file:
BUFFER_LENGTH	test_client.c	19;"	d	file:
BUF_SIZE	s.c	5;"	d	file:
CFLAGS	GNUmakefile	/^CFLAGS=-g -O0$/;"	m
CPPFLAGS	GNUmakefile	/^CPPFLAGS=-I ..\/..\/include\/$/;"	m
CXXFLAGS	GNUmakefile	/^CXXFLAGS=-g -O0 -Wall -Wextra -std=c++0x$/;"	m
Child	test_Polymorphism.cpp	/^	Child() {$/;"	f	class:Child
Child	test_Polymorphism.cpp	/^class Child: public Parent$/;"	c	file:
ClassA	test_new.cc	/^	ClassA() {$/;"	f	class:ClassA
ClassA	test_new.cc	/^class ClassA{$/;"	c	file:
DATE_MAX	../../include/logging.h	37;"	d
Eat	test_Polymorphism.cpp	/^	int Eat() {$/;"	f	class:Child
Eat	test_Polymorphism.cpp	/^	virtual int Eat() {$/;"	f	class:Parent
IP_LENGTH	test_client.c	18;"	d	file:
LOGGING_H	../../include/logging.h	9;"	d
MAX_EVENTS	test_client.c	17;"	d	file:
MAX_LENGTH	bignumber_multiplication.c	3;"	d	file:
MODE_MAX	../../include/logging.h	36;"	d
NMEMB_MAX	middle_number.c	7;"	d	file:
Parent	test_Polymorphism.cpp	/^	Parent() {$/;"	f	class:Parent
Parent	test_Polymorphism.cpp	/^class Parent {$/;"	c	file:
People	test_class.cc	/^	People() {}$/;"	f	class:People
People	test_class.cc	/^class People {$/;"	c	file:
SIZE_500MB	find_not_include_number.c	6;"	d	file:
SIZE_MAX	../../include/logging.h	16;"	d
SIZE_MAX	../../include/logging.h	18;"	d
TABLE_SIZE	s.c	4;"	d	file:
XXX	test_da.cc	/^struct XXX{$/;"	s	file:
__MAX	test_pthread.c	17;"	d	file:
__MAX	test_pthread_with_lock.c	24;"	d	file:
__MAX	test_pthread_with_sync.c	21;"	d	file:
__plog	../../include/logging.cc	/^int __plog(enum elevel x, const char *__file, unsigned int __line, const char *__function, const char *fmt, ...)$/;"	f
a	test_da.cc	/^int* a() const { std::cout << "22222222"; return &a1; }$/;"	f	struct:XXX
a	test_da.cc	/^int* a() { std::cout << "11111111"; return &a1; }$/;"	f	struct:XXX
a1	test_da.cc	/^int a1;$/;"	m	struct:XXX	file:
alert	../../include/logging.h	/^	alert,			\/* action must be taken immediately *\/$/;"	e	enum:elevel
buf	s.c	/^struct num buf[BUF_SIZE];$/;"	v	typeref:struct:num
bufsize	generate_data.c	7;"	d	file:
bye	test_atexit.c	/^bye(void)$/;"	f
cache	../../include/logging.h	/^	unsigned int cache; \/\/ logging has cache lines in memory$/;"	m	struct:logging
cache_max	../../include/logging.h	/^	unsigned int cache_max; \/\/ cache_max lines in memory$/;"	m	struct:logging
cal	bignumber_multiplication.c	/^int cal(const char *number_x, const char *number_y, char *number_result) {$/;"	f
callback	test_sqlite3.c	/^int callback(void *NotUsed, int argc, char **argv, char **colname)$/;"	f
clear_color	../../include/logging.cc	/^const char *clear_color = "\\e[0m";$/;"	v
color	../../include/logging.cc	/^const char *color[debug + 1] = $/;"	v
count	test_client.c	/^int count = 0;$/;"	v
count	test_pthread_with_sync.c	/^int count = 0;$/;"	v
critical	../../include/logging.h	/^	critical,		\/* critical conditions *\/$/;"	e	enum:elevel
data	test_MYqueue.c	/^	int data;$/;"	m	struct:entry	file:
debug	../../include/logging.h	/^	debug,			\/* debug-level messages *\/$/;"	e	enum:elevel
diff	../../include/logging.h	/^	time_t diff; \/\/ time interval$/;"	m	struct:logging
do_something	test_logging.cc	/^int do_something(enum elevel x, int timeout)$/;"	f
do_use_fd	test_client.c	/^int do_use_fd()$/;"	f
dummy	test_new.cc	/^	char dummy[1024*1024];$/;"	m	class:ClassA	file:
elevel	../../include/logging.h	/^enum elevel {$/;"	g
emergency	../../include/logging.h	/^	emergency,		\/* application is unusable *\/$/;"	e	enum:elevel
entry	test_MYqueue.c	/^struct entry {$/;"	s	file:
error	../../include/logging.h	/^	error,			\/* error conditions *\/$/;"	e	enum:elevel
example	test_aaa.c	/^For example, after three jump commands you have this jump list:$/;"	v
f	test_lambda.cc	/^auto f = [] { return 42 };$/;"	v
fds	test_client.c	/^int fds[MAX_EVENTS] = {0};$/;"	v
flag	test_new.cc	/^bool flag = false;$/;"	v
fvar	a.sh	/^function fvar() {$/;"	f
h	s.c	/^    unsigned short h;$/;"	m	struct:num	file:
handler	test_logging.cc	/^void handler(int signum)$/;"	f
head	test_MYqueue.c	/^	struct entry *head;$/;"	m	struct:queue	typeref:struct:queue::entry	file:
host	test_client.c	/^char host[1024];$/;"	v
i_want_to_get_this_content	test_curl.c	/^int i_want_to_get_this_content(const char *url) {$/;"	f
info	../../include/logging.h	/^	info,			\/* informational *\/$/;"	e	enum:elevel
initializing	../../include/logging.cc	/^int initializing(const char *name, const char *path, const char *mode, enum elevel stream_level, enum elevel stdout_level, time_t diff, unsigned int cache_max, unsigned long size_max)$/;"	f
l	../../include/logging.cc	/^struct logging *l;$/;"	v	typeref:struct:logging
l	s.c	/^    unsigned short l;$/;"	m	struct:num	file:
length	test_MYqueue.c	/^	size_t length;$/;"	m	struct:queue	file:
level	../../include/logging.cc	/^const char *level[debug + 1] = $/;"	v
list	test_aaa.c	/^:ju[mps]	Print the jump list (not a motion command).  {not in $/;"	f
list	test_aaa.c	/^CTRL-O		Go to [count] Older cursor position in jump list $/;"	f
logging	../../include/logging.h	/^struct logging {$/;"	s
main	a.c	/^int main() {$/;"	f
main	a.cc	/^int main() {$/;"	f
main	bignumber_multiplication.c	/^int main() {$/;"	f
main	file.c	/^int main(int argc, char **argv)$/;"	f
main	find_not_include_number.c	/^int main() {$/;"	f
main	generate_data.c	/^int main()$/;"	f
main	middle_number.c	/^int main() {$/;"	f
main	s.c	/^int main()$/;"	f
main	test_FILE.c	/^int main(int argc, char **argv)$/;"	f
main	test_MYqueue.c	/^int main() {$/;"	f
main	test_Polymorphism.cpp	/^int main() {$/;"	f
main	test_aaa.c	/^int main()$/;"	f
main	test_atexit.c	/^main(void)$/;"	f
main	test_base64.c	/^int main(int argc, char **argv) {$/;"	f
main	test_class.cc	/^int main(int argc, char **argv) {$/;"	f
main	test_client.c	/^int main(int argc, char **argv)$/;"	f
main	test_const.cc	/^int main()$/;"	f
main	test_curl.c	/^int main(int ac, char **av) {$/;"	f
main	test_da.cc	/^int main() {$/;"	f
main	test_digit.c	/^int main(void)$/;"	f
main	test_equal.c	/^int main(){$/;"	f
main	test_exit.c	/^int main() {$/;"	f
main	test_file.c	/^int main(int argc, char **argv) {$/;"	f
main	test_fread.c	/^int main() {$/;"	f
main	test_gethostbyaddr.c	/^int main(int argc, char **argv) {$/;"	f
main	test_gnu.c	/^int main(void) {$/;"	f
main	test_lambda.cc	/^int main(int argc, char **argv) {$/;"	f
main	test_list.cc	/^int main(void) {$/;"	f
main	test_logging.cc	/^int main(int argc, char **argv)$/;"	f
main	test_map.cc	/^int main(void) {$/;"	f
main	test_multimap.cc	/^int main(void) {$/;"	f
main	test_new.cc	/^int main() {$/;"	f
main	test_or.c	/^int main(int ac, char **argv) {$/;"	f
main	test_protobuf.cc	/^int main() {$/;"	f
main	test_pthread.c	/^int main() {$/;"	f
main	test_pthread_with_lock.c	/^int main() {$/;"	f
main	test_pthread_with_sync.c	/^int main() {$/;"	f
main	test_queue.cc	/^int main ()$/;"	f
main	test_regex.c	/^int main(int argc, char **argv)$/;"	f
main	test_regex.cpp	/^int main(void) {$/;"	f
main	test_rlimit.c	/^int main() {$/;"	f
main	test_sizeof.c	/^int main() {$/;"	f
main	test_sqlite3.c	/^int main(int argc, char **argv)$/;"	f
main	test_std.c	/^int main(void) {$/;"	f
main	test_string.cc	/^int main(void) {$/;"	f
main	test_thread.cc	/^int main() {$/;"	f
main	test_unorderedmap.cc	/^int main(void) {$/;"	f
main	test_vector.cc	/^int main(int argc, char **argv) {$/;"	f
main	test_xml.c	/^int main(int argc, char **argv) {$/;"	f
main	test_xml2.cc	/^int main(int argc, char **argv) {$/;"	f
mode	../../include/logging.h	/^	char mode[MODE_MAX]; \/\/ logging file's mode$/;"	m	struct:logging
mutex	test_pthread_with_lock.c	/^pthread_mutex_t mutex; \/\/ = PTHREAD_MUTEX_INITIALIZER;$/;"	v
mutex	test_pthread_with_sync.c	/^pthread_mutex_t mutex; \/\/ = PTHREAD_MUTEX_INITIALIZER;$/;"	v
my_write	test_curl.c	/^size_t my_write( void *ptr, size_t size, size_t nmemb, void *stream) {$/;"	f
name	../../include/logging.h	/^	char name[NAME_MAX]; \/\/ program name$/;"	m	struct:logging
nconnect	test_client.c	/^int nconnect = 0;$/;"	v
next	test_MYqueue.c	/^	struct entry *next;$/;"	m	struct:entry	typeref:struct:entry::entry	file:
none	../../include/logging.h	/^	none = -1,		\/* none logging *\/$/;"	e	enum:elevel
notice	../../include/logging.h	/^	notice,			\/* normal but significant condition *\/$/;"	e	enum:elevel
num	s.c	/^struct num$/;"	s	file:
number	../../include/logging.h	/^	unsigned int number; \/\/ logging file's suffix number when splits file$/;"	m	struct:logging
path	../../include/logging.h	/^	char path[PATH_MAX]; \/\/ logging file's path$/;"	m	struct:logging
pflush	../../include/logging.cc	/^int pflush()$/;"	f
pid	../../include/logging.h	/^	pid_t pid; \/\/ program process id$/;"	m	struct:logging
plog	../../include/logging.h	82;"	d
pop_front	test_MYqueue.c	/^int pop_front(struct queue *q) {$/;"	f
previous	test_MYqueue.c	/^	struct entry *previous;$/;"	m	struct:entry	typeref:struct:entry::entry	file:
push_back	test_MYqueue.c	/^int push_back(struct queue *q, int data) {$/;"	f
queue	test_MYqueue.c	/^struct queue {$/;"	s	file:
quit	test_client.c	/^int quit = 0;$/;"	v
quit	test_logging.cc	/^unsigned int quit = 0;$/;"	v
reads	test_client.c	/^int reads(int fd)$/;"	f
regex_content	test_regex.cpp	/^int regex_content(const char * regex, const char * string1, std::list<std::string> &urls) {$/;"	f
set_disposition	test_logging.cc	/^int set_disposition()$/;"	f
setnonblocking	test_client.c	/^int setnonblocking(int fd)$/;"	f
size	../../include/logging.h	/^	unsigned long size; \/\/ logging has written bytes in file$/;"	m	struct:logging
size_max	../../include/logging.h	/^	unsigned long size_max; \/\/ size_max bytes in file$/;"	m	struct:logging
start_routine	test_pthread.c	/^void *start_routine(void *arg) {$/;"	f
start_routine	test_pthread_with_lock.c	/^void *start_routine(void *arg) {$/;"	f
start_routine	test_pthread_with_sync.c	/^void *start_routine(void *arg) {$/;"	f
stdout_level	../../include/logging.h	/^	enum elevel stdout_level;$/;"	m	struct:logging	typeref:enum:logging::elevel
stream	../../include/logging.h	/^	FILE *stream;$/;"	m	struct:logging
stream_level	../../include/logging.h	/^	enum elevel stream_level;$/;"	m	struct:logging	typeref:enum:logging::elevel
sysdate	../../include/logging.cc	/^int sysdate(char *str)$/;"	f
t0	../../include/logging.h	/^	struct tm t0; \/\/ start time$/;"	m	struct:logging	typeref:struct:logging::tm
t1	../../include/logging.h	/^	struct tm t1; \/\/ the last flush stream date\/time$/;"	m	struct:logging	typeref:struct:logging::tm
tail	test_MYqueue.c	/^	struct entry *tail;$/;"	m	struct:queue	typeref:struct:queue::entry	file:
tb	s.c	/^uint32_t tb[TABLE_SIZE];$/;"	v
uninitialized	../../include/logging.cc	/^int uninitialized()$/;"	f
usage	test_client.c	/^int usage(const char *argv0)$/;"	f
warning	../../include/logging.h	/^	warning,		\/* warning conditions *\/$/;"	e	enum:elevel
writes	test_client.c	/^int writes(int fd)$/;"	f
~Child	test_Polymorphism.cpp	/^	~Child() {$/;"	f	class:Child
~Parent	test_Polymorphism.cpp	/^	virtual ~Parent() {$/;"	f	class:Parent
~People	test_class.cc	/^	~People() {}$/;"	f	class:People
